# ConvTranspose2d

# 设定一个最简单例子

我们用：

* 输入 feature：2×2
* ConvTranspose2d 参数：

```
kernel = 2×2
stride = 2
padding = 0
bias = 0
```

权重 kernel：

```
W =
[[1, 2],
 [3, 4]]
```

输入 X：

```
X =
[[5, 6],
 [7, 8]]
```

---

# ConvTranspose 的规则（二维）

核心机制：

---

## 每一个输入像素

→ 乘 kernel

→ “铺”到输出空间对应区域

→ 重叠位置相加

---

不是滑窗。

而是：

---

# pixel splatting

---

我们开始。

---

# Step 1：初始化输出

stride=2，输入 2×2，kernel 2×2：

输出大小：

```
(2-1)*2 + 2 = 4
```

所以：

```
Output = 4×4 全 0
```

---

```
O =
[[0,0,0,0],
 [0,0,0,0],
 [0,0,0,0],
 [0,0,0,0]]
```

---

# Step 2：处理 X[0,0] = 5

位置：

```
(0*2, 0*2) = (0,0)
```

乘 kernel：

```
5×W =
[[5,10],
 [15,20]]
```

加到输出左上：

```
O =
[[ 5,10, 0, 0],
 [15,20, 0, 0],
 [ 0, 0, 0, 0],
 [ 0, 0, 0, 0]]
```

---

# Step 3：处理 X[0,1] = 6

位置：

```
(0*2,1*2) = (0,2)
```

kernel ×6：

```
[[ 6,12],
 [18,24]]
```

加到：

```
O =
[[ 5,10, 6,12],
 [15,20,18,24],
 [ 0, 0, 0, 0],
 [ 0, 0, 0, 0]]
```

---

# Step 4：处理 X[1,0] = 7

位置：

```
(2,0)
```

7×kernel：

```
[[ 7,14],
 [21,28]]
```

加：

```
O =
[[ 5,10, 6,12],
 [15,20,18,24],
 [ 7,14, 0, 0],
 [21,28, 0, 0]]
```

---

# Step 5：处理 X[1,1] = 8

位置：

```
(2,2)
```

8×kernel：

```
[[ 8,16],
 [24,32]]
```

最终：

```
O =
[[ 5,10, 6,12],
 [15,20,18,24],
 [ 7,14, 8,16],
 [21,28,24,32]]
```

---

# 🎉 这就是 ConvTranspose2d 的完整结果。

---

# 你现在应该清楚看到：

---

## 没有 sliding window

## 是每个输入点往外“撒 kernel”

---

# 如果 stride=1 会怎样？

区域会重叠：

重叠位置直接相加：

---

这正是 checkerboard 来源。

---

# 一眼记住：

---

## Conv2d：

窗口在图上滑。

---

## ConvTranspose2d：

像素在图上炸。

---

---

# 对比 Upsample（同输入）

如果用：

```python
Upsample(scale=2, nearest)
```

X：

```
[[5,6],
 [7,8]]
```

变：

```
[[5,5,6,6],
 [5,5,6,6],
 [7,7,8,8],
 [7,7,8,8]]
```

完全不同。

---

# 最终总结（用你现在能感知的二维）

---

ConvTranspose2d 在 2D 中：

---

# 每个输入元素乘 kernel，按 stride 间隔铺开，相加形成输出。

---

不是逆卷积。

不是插值。

是：

---

# pixel → patch

---
